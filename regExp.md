##正则表达式
ES3和ES5中对于正则表达式直接量返回的对象定义不一致问题:   
ES3对同一段正则表达式返回同一正则表达式对象，ES5每个正则表达式都会返回不同的实例对象(IE6~8按ES5的规范实现，firefox4,chrome)
```javascript
function reReg(){
	var reg = /RegExp/;
	reg.foo = "foo";
	return reg;
}
var reg = reReg();
var reg2 = reReg();
//ES3里面reg和reg2是同一个对象 ES5里面是不同的对象
//当前的现代浏览器基本都实现了ES5的规范
//这里面也说明一个问题循环中 var x = [];每次都会返回不同的数组(实例)对象，以后重置数组要用 x.length = 0;
```
     
正则表达式的特殊字符   
<code>^ $ . * + ? = ! : | \ / ( ) [ ] { }</code>   
直接量字符   
<code>\o \t \v \f \r \n \xnn \uxxxx \cX </code>   
    
    
字符类  
将直接量字符单独放到中括号里就组成了的字符类，一个字符类可以匹配它所包含的任意字符   
a-b中的连字符表示范围
```javascript
var regAbc = /[abc]/;  //匹配字符'a', 'b', 'c'中的任意一个
var regNotAbc = /[^abc]/; //匹配除字符'a', 'b', 'c'以外的所有的字符
var regW = /[a-zA-Z0-9]/;  //匹配a到z, A到Z， 0到9的字符等同于/\w/
```
特殊的字符类  
*  [...]  匹配...中的任意一个
*  [^...] 匹配除...以外的所有字符
*  .      匹配任意一个除换行符和Unicode行终止符以外的所有字符
*  \w     匹配任意的ASCII字符组成的单词  等同于[a-zA-Z0-9]
*  \W     匹配非ASCII字符组成的单词      等同于[^a-zA-Z0-9]
*  \s     匹配任意的Unicode空白符    
*  \S     匹配任意的非Unicode空白符
*  \d     匹配ASCII数字                 等同于[0-9]
*  \D     匹配非ASCII数字               等同于[^0-9]
*  [\b]   匹配退格符\b(特例)                 不放在字符类里表示边界
   
  
重复   
表示某个元素或者分组出现多少次  
*  {n,m}   匹配至少出现n次，至多出现m次
*  {n,}    匹配至少出现n次，
*  {n}      匹配出现n次
*  ?        匹配出现0次或1次  等同于{0, 1}
*  +        匹配至少出现1次   等同于{1, }
*  *        匹配出现任意次    等同于{0, }  
<code>?*</code>匹配要谨慎使用，因为可以匹配零次出现
```javascript
	var reg = /a?b{3}/;
	reg.test("bbb"); //=>true 匹配a0次
```
正则表达式的匹配原理：从第一个位置开始查找最远的位置，看是否匹配，不匹配依次减少字符串的长度,直到减少到本身没有查找。就从第二个位置开始再次查找。就是贪婪匹配
要让正则表达式的匹配变为非贪婪，在重复的后面加<code>?</code>.  <code>{2, 4}?</code> <code>??</code>  
```javascript
	/\d{3,7}/.exec("abc1234567"); //=>1234567;
	//匹配流程: a不匹配， b不匹配， c不匹配，1匹配一部分，1234567完全匹配 
	/\d{3,7}?/.exec("abc1234567");  //=>123;
	//匹配流程: a不匹配， b不匹配， c不匹配 1匹配一部分 12匹配一部分 123完全匹配
```
使用非贪婪模式可能得到跟预期不符的内容.
```javascript
	var reg = /a+?b/;
	var match = reg.exec("aaab"); //=>match[0]: aaab;
	//虽然这个是非贪婪的匹配，但是正则匹配的工作原理
	//从第一个的位置查找 aa,不匹配,然后查找aaa，还不匹配，查找aaab,匹配就完成了
```
  
   
选择、分组、引用   
*  |  选择  选择匹配项，选择项总是从左到右匹配的，如果左边的表达式匹配成功，右边的匹配项直接忽略   /a|ab/ 匹配"ab" 得到的结果是"a"
*  () 分组  把几个项组合到一起，可以运用重复等修饰符，也可以记忆以引用
*  \n[n] 表示分组的反向引用,嵌套的分组的顺序是(开始的顺序
*  (?:) 只分组
   
   
位置
*  ^  匹配字符串的开头， 在多行检索中, 匹配一行的开头
*  $  匹配字符串的结尾， 在多行检索中, 匹配一行的结尾
*  \b  匹配一个单词的边界(\w和\W)
*  \B   不以p为前分界
*  (?=p) 零宽正向先行断言,要求接下的字符要p匹配，但不能包括匹配p的字符
*  (?!p) 零宽负向先行断言,要求接下的字符不要p匹配


修饰符   
修饰符用户第二个/的后面，或者是RegExp的第二个参数   
*  i 忽略大小写
*  g 是否执行全局搜索
*  m 是否进行多行检索, <code>^$</code>将会匹配每一行的开头和结尾
   
   
正则表达式对象的属性和方法   
*  ignoreCase 是否设置了修饰符i
*  global     是否设置了修饰符g
*  multiLine  是否设置了修饰符m
*  source     返回正则表达式的主体，返回直接量的主体的 (new RegExg("\\d")).source =>"\d"
*  lastIndex  返回字符串下一次开始检索的位置，如果不是全局检索，返回0
*  下面为方法
*  test       传入的字符串是否匹配
*  exec       如果能够匹配 返回一个数组，第一项为匹配的字符串，第二项...第N项为正则表达式的里面分组的匹配的字符串, 里面还有两个属相index、input, input为传入字符串，index为匹配项在字符串的中的索引位置,不匹配返回null





   
    


